

## 作用
保证变量对所有的线程的可见性，当一个线程修改了这个变量的值，其他线程可以立即知道这个新值（之所以有可见性的问题，是因为java的内存模型）

## 原理

所有变量都存在主内存，每条线程有自己的工作内存，工作内存保存了被该线程使用的变量的主内存副本拷贝
线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存的变量，也就是必须先通过工作内存
一个线程不能访问另一个线程的工作内存
volatile保证了变量更新的时候能够立即同步到主内存，使用变量的时候能立即从主内存刷新到工作内存，这样就保证了变量的可见性
实际上是通过内存屏障来实现的。语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。

![](https://images2017.cnblogs.com/blog/900751/201708/900751-20170809175926042-624326373.jpg)